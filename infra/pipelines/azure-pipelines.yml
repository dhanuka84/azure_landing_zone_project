trigger:
  branches: { include: [ main ] }
  paths: { include: [ infra/** ] }

variables:
- group: vg-terraform

# Define the OIDC-based service connection names
# These connections are configured in Azure DevOps with "Workload Identity federation"
variables:
  SERVICE_CONNECTION_PLATFORM: "azrm-oidc-platform"
  SERVICE_CONNECTION_NONPROD: "azrm-oidc-nonprod"
  SERVICE_CONNECTION_PROD: "azrm-oidc-prod"

stages:
- stage: platform_mg
  displayName: "Platform :: Management Groups & Policy"
  jobs:
  - job: tf
    pool: { vmImage: 'ubuntu-latest' }
    steps:
    - task: TerraformInstaller@1
      inputs:
        terraformVersion: '1.13.4'
    - task: TerraformCLI@1
      displayName: "Init (MG)"
      inputs:
        command: 'init'
        workingDirectory: 'infra/platform/mg'
        backendType: 'azurerm'
        serviceConnection: $(SERVICE_CONNECTION_PLATFORM) 
        ensureBackend: true
        backendAzureRmResourceGroupName: '$(TF_STATE_RG)'
        backendAzureRmStorageAccountName: '$(TF_STATE_SA)'
        backendAzureRmContainerName: '$(TF_STATE_CONTAINER)'
        backendAzureRmKey: '$(TF_STATE_KEY_PLATFORM_MG)'
    - task: TerraformCLI@1
      displayName: "Validate (MG)"
      inputs:
        command: 'validate'
        workingDirectory: 'infra/platform/mg'
    - task: TerraformCLI@1
      displayName: "Plan (MG)"
      inputs:
        command: 'plan'
        workingDirectory: 'infra/platform/mg'
        serviceConnection: $(SERVICE_CONNECTION_PLATFORM)
        commandOptions: '-out=tfplan'
    - task: TerraformCLI@1
      displayName: "Apply (MG)"
      inputs:
        command: 'apply'
        workingDirectory: 'infra/platform/mg'
        serviceConnection: $(SERVICE_CONNECTION_PLATFORM)
        commandOptions: 'tfplan'

- stage: platform_connectivity
  displayName: "Platform :: Connectivity (Hub VNet + Firewall + NSGs)"
  dependsOn: platform_mg
  jobs:
  - job: tf
    pool: { vmImage: 'ubuntu-latest' }
    steps:
    - task: TerraformInstaller@1
      inputs:
        terraformVersion: '1.13.4'
    - task: TerraformCLI@1
      displayName: "Init (Connectivity)"
      inputs:
        command: 'init'
        workingDirectory: 'infra/platform/connectivity'
        backendType: 'azurerm'
        serviceConnection: $(SERVICE_CONNECTION_PLATFORM)
        ensureBackend: true
        backendAzureRmResourceGroupName: '$(TF_STATE_RG)'
        backendAzureRmStorageAccountName: '$(TF_STATE_SA)'
        backendAzureRmContainerName: '$(TF_STATE_CONTAINER)'
        backendAzureRmKey: '$(TF_STATE_KEY_CONNECTIVITY)'
    - task: TerraformCLI@1
      displayName: "Validate (Connectivity)"
      inputs:
        command: 'validate'
        workingDirectory: 'infra/platform/connectivity'
    - task: TerraformCLI@1
      displayName: "Plan (Connectivity)"
      inputs:
        command: 'plan'
        workingDirectory: 'infra/platform/connectivity'
        serviceConnection: $(SERVICE_CONNECTION_PLATFORM)
        commandOptions: '-var-file=hub.tfvars -out=tfplan'
    - task: TerraformCLI@1
      displayName: "Apply (Connectivity)"
      inputs:
        command: 'apply'
        workingDirectory: 'infra/platform/connectivity'
        serviceConnection: $(SERVICE_CONNECTION_PLATFORM)
        commandOptions: 'tfplan'

- stage: env_dev
  displayName: "Env :: Dev"
  dependsOn: platform_connectivity
  jobs:
  - job: tf
    pool: { vmImage: 'ubuntu-latest' }
    steps:
    - task: TerraformInstaller@1
      inputs:
        terraformVersion: '1.13.4'
    - task: TerraformCLI@1
      displayName: "Init (Dev)"
      inputs:
        command: 'init'
        workingDirectory: 'infra/envs/dev'
        backendType: 'azurerm'
        serviceConnection: $(SERVICE_CONNECTION_NONPROD)
        ensureBackend: true
        backendAzureRmResourceGroupName: '$(TF_STATE_RG)'
        backendAzureRmStorageAccountName: '$(TF_STATE_SA)'
        backendAzureRmContainerName: '$(TF_STATE_CONTAINER)'
        backendAzureRmKey: '$(TF_STATE_KEY_DEV)'
    - task: TerraformCLI@1
      displayName: "Validate (Dev)"
      inputs:
        command: 'validate'
        workingDirectory: 'infra/envs/dev'
    - task: TerraformCLI@1
      displayName: "Plan (Dev)"
      inputs:
        command: 'plan'
        workingDirectory: 'infra/envs/dev'
        serviceConnection: $(SERVICE_CONNECTION_NONPROD)
        commandOptions: '-var-file=dev.tfvars -out=tfplan'
    - task: TerraformCLI@1
      displayName: "Apply (Dev)"
      inputs:
        command: 'apply'
        workingDirectory: 'infra/envs/dev'
        serviceConnection: $(SERVICE_CONNECTION_NONPROD)
        commandOptions: 'tfplan'

- stage: env_qa
  displayName: "Env :: QA"
  dependsOn: env_dev
  jobs:
  - job: tf
    pool: { vmImage: 'ubuntu-latest' }
    steps:
    - task: TerraformInstaller@1
      inputs:
        terraformVersion: '1.13.4'
    - task: TerraformCLI@1
      displayName: "Init (QA)"
      inputs:
        command: 'init'
        workingDirectory: 'infra/envs/qa'
        backendType: 'azurerm'
        serviceConnection: $(SERVICE_CONNECTION_NONPROD)
        ensureBackend: true
        backendAzureRmResourceGroupName: '$(TF_STATE_RG)'
        backendAzureRmStorageAccountName: '$(TF_STATE_SA)'
        backendAzureRmContainerName: '$(TF_STATE_CONTAINER)'
        backendAzureRmKey: '$(TF_STATE_KEY_QA)'
    - task: TerraformCLI@1
      displayName: "Validate (QA)"
      inputs:
        command: 'validate'
        workingDirectory: 'infra/envs/qa'
    - task: TerraformCLI@1
      displayName: "Plan (QA)"
      inputs:
        command: 'plan'
        workingDirectory: 'infra/envs/qa'
        serviceConnection: $(SERVICE_CONNECTION_NONPROD)
        commandOptions: '-var-file=qa.tfvars -out=tfplan'
    - task: TerraformCLI@1
      displayName: "Apply (QA)"
      inputs:
        command: 'apply'
        workingDirectory: 'infra/envs/qa'
        serviceConnection: $(SERVICE_CONNECTION_NONPROD)
        commandOptions: 'tfplan'

- stage: env_prod
  displayName: "Env :: Prod"
  dependsOn: env_qa
  jobs:
  # Use a 'deployment' job to enable manual approvals
  - deployment: tf_prod
    displayName: "Terraform Apply (Prod)"
    pool: { vmImage: 'ubuntu-latest' }
    environment: 'production' # This enables manual approval checks
    strategy:
      runOnce:
        deploy:
          steps:
          - task: TerraformInstaller@1
            inputs:
              terraformVersion: '1.13.4'
          - task: TerraformCLI@1
            displayName: "Init (Prod)"
            inputs:
              command: 'init'
              workingDirectory: 'infra/envs/prod'
              backendType: 'azurerm'
              serviceConnection: $(SERVICE_CONNECTION_PROD)
              ensureBackend: true
              backendAzureRmResourceGroupName: '$(TF_STATE_RG)'
              backendAzureRmStorageAccountName: '$(TF_STATE_SA)'
              backendAzureRmContainerName: '$(TF_STATE_CONTAINER)'
              backendAzureRmKey: '$(TF_STATE_KEY_PROD)'
          - task: TerraformCLI@1
            displayName: "Validate (Prod)"
            inputs:
              command: 'validate'
              workingDirectory: 'infra/envs/prod'
          - task: TerraformCLI@1
            displayName: "Plan (Prod)"
            inputs:
              command: 'plan'
              workingDirectory: 'infra/envs/prod'
              serviceConnection: $(SERVICE_CONNECTION_PROD)
              commandOptions: '-var-file=prod.tfvars -out=tfplan'
          - task: TerraformCLI@1
            displayName: "Apply (Prod)"
            inputs:
              command: 'apply'
              workingDirectory: 'infra/envs/prod'
              serviceConnection: $(SERVICE_CONNECTION_PROD)
              commandOptions: 'tfplan'